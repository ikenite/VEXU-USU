#pragma config(Sensor, dgtl1,  IntakeOne,      sensorDigitalIn)
#pragma config(Sensor, dgtl2,  IntakeTwo,      sensorDigitalIn)
#pragma config(Sensor, dgtl3,  IntakeThree,    sensorDigitalIn)
#pragma config(Sensor, dgtl7,  Flywheel,       sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  LeftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, RightDrive,     sensorQuadEncoder)
#pragma config(Motor,  port1,           BLDrive,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           TMFly,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           TFly,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Conveyor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           FRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BFly,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BMFly,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          FLDrive,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void FlyPower(int Power)
{
	motor[TFly]  = Power;
	motor[TMFly] = Power;
	motor[BMFly] = Power;
	motor[BFly]  = Power;
}

float Velocity;
float MainBattery;
task BackgroundInfo()  // Calculates the speed of flywheel by dividing change in encoder value by change in time
// Calculates Battery voltage from the main battery
{
	resetTimer(T1);
	SensorValue[Flywheel] = 0;
	int FlyInitial;
	int FlyFinal;
	int TimeInitial;
	int TimeFinal;
	wait1Msec(1);
	while(true)
	{
		FlyInitial  = abs(SensorValue[Flywheel]);
		TimeInitial = time1(T1)/60;
		wait1Msec(60);
		FlyFinal  = abs(SensorValue[Flywheel]);
		TimeFinal = time1(T1)/60;
		Velocity  = (FlyFinal - FlyInitial)/(TimeFinal - TimeInitial);

		MainBattery = nAvgBatteryLevel/100;
	}
}

int Launch;
void FlyControl(int target, int hold) // Controls the speed of flywheel, goes either full speed or holding speed
{
	if(Velocity < target)
	{
		FlyPower(127);
	}
	else
	{
		FlyPower(hold);
	}
	if(Velocity < .97*target)
	{
		Launch = 0;
	}
	else
	{
		Launch = 1;
	}
}


void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	startTask(BackgroundInfo);
}

task usercontrol()
{
	startTask(BackgroundInfo);
	int hold     = 0;
	int distance = 0;
	float Bks = .0003;
	float Bkm = .0002;
	float Bkl = .00015;
	Launch = 1;
	while (true)
	{
		FlyControl(distance, hold);
		if (vexRT[Btn7R] == 1)
		{
			distance = -10;
			hold     = 0;
			//FlyPower(70);
		}
		else if (vexRT[Btn7D] == 1)
		{
			distance = 140;
			hold     = 1/(Bks*MainBattery);
			//FlyPower(80);
		}
		else if (vexRT[Btn7L] == 1)
		{
			distance = 155;
			hold     = 1/(Bkm*MainBattery);
			//FlyPower(90);
		}
		else if (vexRT[Btn7U] == 1)
		{
			distance = 200;
			hold     = 1/(Bkl*MainBattery);
			//FlyPower(100);
		}

		// Feed Control //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (vexRT[Btn6U] == 1)
		{
			motor[Intake] = 127;
		}
		else if (vexRT[Btn6D] == 1)
		{
			motor[Intake] = -127;
		}
		else
		{
			motor[Intake] = 0;
		}

		if (vexRT[Btn5D] == 0) // Picking-up mode
		{
			if (SensorValue[IntakeOne] == 0 && SensorValue[IntakeThree] == 1)
			{
				motor[Conveyor] = 127;
			}
			else if (SensorValue[IntakeTwo] == 0 && SensorValue[IntakeOne] == 1)
			{
				motor[Conveyor] = 0;
			}
			else
			{
				motor[Conveyor] = 0;
			}

		}
		else // Firing mode
		{
			if (Launch == 1)         // Fire
			{
				motor[Conveyor] = 127;
			}
			else                     // Hold
			{
				motor[Conveyor] = 0;
			}
		}
		// Drive Control ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		motor[BLDrive] = vexRT[Ch3];
		motor[FLDrive] = vexRT[Ch3];
		motor[BRDrive] = vexRT[Ch2];
		motor[FRDrive] = vexRT[Ch2];
	}
}
